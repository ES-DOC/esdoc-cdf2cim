import re

import cf

from .find_files import find_files


def find_simulations(inputs):
    
    # Dictionary of simulations: key = a unique simulation identifier,
    # value = a list of fields for the simulation.
    simulations = {}
    
    # Dictionary of simulation dates: key = a unique simulation
    # identifier, value = a list of date-time objects which define the
    # time span of the simulation.
    simulation_dates = {}
    
    files = find_files(inputs)

    for filename in files:
        for f in cf.read(filename, ignore_read_error=True, verbose=False, aggregate=False):
    
            # Get the time coordinates
            time_coords = f.dim('T')
            
            if time_coords is None or not time_coords.Units.isreftime or time_coords.ndim > 1:
                # No (suitable) time coordinates
                cf.close_one_file()
                continue
    
            properties = f.properties #(copy=False)
            cim2_properties = {}
    
            if properties.get('mip_era') == 'CMIP6':
                mapping = cmip6_to_cim2
            elif properties.get('project_id') == 'CMIP5':
                mapping = cmip5_to_cim2
    
            for cmip_attr, cim2_attr in mapping.iteritems():
                if cim2_attr is None:
                    continue
                cim2_properties[cim2_attr] = properties.pop(cmip_attr, None)
    
            cim2_properties['calendar'] = getattr(t, 'calendar', 'gregorian')
            cim2_properties.pop(None, None)
    
            if mapping is cmip6_to_cim2:
                # Special CMIP6 to CIM2 processing which has not been
                # provided by the mapping
                
                # parent_variant_label
                cim2_properties.update(
                    zip(['parent_realization_index',
                         'parent_initialization_index',
                         'parent_physics_index',
                         'parent_forcing_index'],
                        re.findall('\d+', properties.get('parent_variant_label', 'none'))))
    
                # branch_time_in_child
                # branch_time_in_parent
                # parent_time_units
                parent_branch_units = properties.get('parent_branch_units')            
                if parent_time_units is None:
                    parent_time_units = time_coords.Units
                else:                
                    m = re.match('(.*) *\((.*?)\)', parent_time_units)
                    if m:
                        parent_time_units = cf.Units(*m.groups())
                    else:
                        parent_time_units = cf.Units(parent_time_units, 
                                                     cim2_properties['calendar'])
                
                branch_time_in_parent = properties.get('branch_time_in_parent')
                if branch_time_in_parent is not None:
                    x = cf.Data([branch_time_in_parent], parent_time_units).dtarray[0]
                    cim2_properties['branch_time_in_parent'] = str(x)
                    
                branch_time_in_child = properties.get('branch_time_in_child')
                if branch_time_in_child is not None:
                    x = cf.Data([branch_time_in_child], time_coords.Units).dtarray[0]
                    cim2_properties['branch_time'] = str(x)
                    
            elif mapping is cmip5_to_cim2:
                # Special CMIP5 to CIM2 processing which has not been
                # provided by the mapping
                pass

            simulation_id = tuple(sorted(cim2_properties.items()))

            simulations.setdefault(simulation_id, []).append(f)
            
            # --------------------------------------------------------
            # Find the earliest and latest dates for this field
            # --------------------------------------------------------
            if time_coords.size == 1:
                index = 0
            else:
                index = [0, -1]

            if time_coords.hasbounds:
                # Get the time span from the time coordinate bounds
                dates = time_coords.bounds.subspace[index].dtarray.flat
            else:
                # In the absence of bounds, get the time span from the
                # time coordinates
                dates = time_coords.subspace[index].dtarray
            
            # Add the first and last time_coords to the list of
            # date-time_coords for this simulation
            simulation_dates.setdefault(simulation_id, []).extend(dates)    
         #--- End: for

         # Close the file to prevent a proliferation of open file
         # handles
         cf.close_one_file()
    #--- End: for
